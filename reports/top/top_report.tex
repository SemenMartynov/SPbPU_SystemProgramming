\documentclass[a4paper, 12pt]{article}		% general format

%%%% Charset
\usepackage{cmap}							% make PDF files searchable and copyable
\usepackage[utf8x]{inputenc}				% accept different input encodings
\usepackage[T2A]{fontenc}					% russian font
\usepackage[russian]{babel}					% multilingual support (T2A)

%%%% Graphics
\usepackage[dvipsnames]{xcolor}			% driver-independent color extensions
\usepackage{graphicx}						% enhanced support for graphics
\usepackage{wrapfig}						% produces figures which text can flow around

%%%% Math
\usepackage{amsmath}						% American Mathematical Society (AMS) math facilities
\usepackage{amsfonts}						% fonts from the AMS
\usepackage{amssymb}						% additional math symbols

%%%% Typograpy (don't forget about cm-super)
\usepackage{microtype}						% subliminal refinements towards typographical perfection
\linespread{1.3}							% line spacing
\usepackage[left=2.5cm, right=1.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\setlength{\parindent}{0pt}					% we don't want any paragraph indentation
\usepackage{parskip}
%\renewcommand{\chaptername}{}

%%%% Other
\usepackage{url}							% verbatim with URL-sensitive line breaks
\makeatletter
\renewcommand{\@biblabel}[1]{#1.\hfill}
\makeatother

%------------------------------------------------------------------------------
\usepackage{listings}						% typeset source code listings

% Цвета для кода
\definecolor{string}{HTML}{101AF9}			% цвет строк в коде
\definecolor{comment}{HTML}{3F7F5F}		% цвет комментариев в коде
\definecolor{keyword}{HTML}{5F1441}		% цвет ключевых слов в коде
\definecolor{morecomment}{HTML}{8000FF}	% цвет include и других элементов в коде
\definecolor{captiontext}{HTML}{FFFFFF}	% цвет текста заголовка в коде
\definecolor{captionbk}{HTML}{999999}		% цвет фона заголовка в коде
\definecolor{bk}{HTML}{FFFFFF}				% цвет фона в коде
\definecolor{frame}{HTML}{999999}			% цвет рамки в коде

% Настройки отображения кода
\lstset{
	language=C++,							% Язык кода по умолчанию
	morekeywords={*,...},					% если хотите добавить ключевые слова, то добавляйте
	% Цвета
	keywordstyle=\color{keyword}\ttfamily\bfseries,
	stringstyle=\color{string}\ttfamily,
	commentstyle=\color{comment}\ttfamily\itshape,
	morecomment=[l][\color{morecomment}]{\#},
	% Настройки отображения
	breaklines=true,						% Перенос длинных строк
	basicstyle=\ttfamily\footnotesize,		% Шрифт для отображения кода
	backgroundcolor=\color{bk},				% Цвет фона кода
	%frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep, % Рамка, подогнанная к заголовку
	frame=tblr								% draw a frame at all sides of the code block
	rulecolor=\color{frame},				% Цвет рамки
	tabsize=2,								% tab space width
	showstringspaces=false,					% don't mark spaces in strings
	% Настройка отображения номеров строк. Если не нужно, то удалите весь блок
	numbers=left,							% Слева отображаются номера строк
	stepnumber=1,							% Каждую строку нумеровать
	numbersep=5pt,							% Отступ от кода
	numberstyle=\small\color{black},		% Стиль написания номеров строк
	% Для отображения русского языка
	extendedchars=true,
	literate={Ö}{{\"O}}1
	 	{Ä}{{\"A}}1
	 	{Ü}{{\"U}}1
		{ß}{{\ss}}1
		{ü}{{\"u}}1
		{ä}{{\"a}}1
		{ö}{{\"o}}1
		{~}{{\textasciitilde}}1
		{а}{{\selectfont\char224}}1
		{б}{{\selectfont\char225}}1
		{в}{{\selectfont\char226}}1
		{г}{{\selectfont\char227}}1
		{д}{{\selectfont\char228}}1
		{е}{{\selectfont\char229}}1
		{ё}{{\"e}}1
		{ж}{{\selectfont\char230}}1
		{з}{{\selectfont\char231}}1
		{и}{{\selectfont\char232}}1
		{й}{{\selectfont\char233}}1
		{к}{{\selectfont\char234}}1
		{л}{{\selectfont\char235}}1
		{м}{{\selectfont\char236}}1
		{н}{{\selectfont\char237}}1
		{о}{{\selectfont\char238}}1
		{п}{{\selectfont\char239}}1
		{р}{{\selectfont\char240}}1
		{с}{{\selectfont\char241}}1
		{т}{{\selectfont\char242}}1
		{у}{{\selectfont\char243}}1
		{ф}{{\selectfont\char244}}1
		{х}{{\selectfont\char245}}1
		{ц}{{\selectfont\char246}}1
		{ч}{{\selectfont\char247}}1
		{ш}{{\selectfont\char248}}1
		{щ}{{\selectfont\char249}}1
		{ъ}{{\selectfont\char250}}1
		{ы}{{\selectfont\char251}}1
		{ь}{{\selectfont\char252}}1
		{э}{{\selectfont\char253}}1
		{ю}{{\selectfont\char254}}1
		{я}{{\selectfont\char255}}1
		{А}{{\selectfont\char192}}1
		{Б}{{\selectfont\char193}}1
		{В}{{\selectfont\char194}}1
		{Г}{{\selectfont\char195}}1
		{Д}{{\selectfont\char196}}1
		{Е}{{\selectfont\char197}}1
		{Ё}{{\"E}}1
		{Ж}{{\selectfont\char198}}1
		{З}{{\selectfont\char199}}1
		{И}{{\selectfont\char200}}1
		{Й}{{\selectfont\char201}}1
		{К}{{\selectfont\char202}}1
		{Л}{{\selectfont\char203}}1
		{М}{{\selectfont\char204}}1
		{Н}{{\selectfont\char205}}1
		{О}{{\selectfont\char206}}1
		{П}{{\selectfont\char207}}1
		{Р}{{\selectfont\char208}}1
		{С}{{\selectfont\char209}}1
		{Т}{{\selectfont\char210}}1
		{У}{{\selectfont\char211}}1
		{Ф}{{\selectfont\char212}}1
		{Х}{{\selectfont\char213}}1
		{Ц}{{\selectfont\char214}}1
		{Ч}{{\selectfont\char215}}1
		{Ш}{{\selectfont\char216}}1
		{Щ}{{\selectfont\char217}}1
		{Ъ}{{\selectfont\char218}}1
		{Ы}{{\selectfont\char219}}1
		{Ь}{{\selectfont\char220}}1
		{Э}{{\selectfont\char221}}1
		{Ю}{{\selectfont\char222}}1
		{Я}{{\selectfont\char223}}1
		{і}{{\selectfont\char105}}1
		{ї}{{\selectfont\char168}}1
		{є}{{\selectfont\char185}}1
		{ґ}{{\selectfont\char160}}1
		{І}{{\selectfont\char73}}1
		{Ї}{{\selectfont\char136}}1
		{Є}{{\selectfont\char153}}1
		{Ґ}{{\selectfont\char128}}1
}

% Для настройки заголовка кода
\usepackage{caption}
\DeclareCaptionFont{white}{\color{сaptiontext}}
\DeclareCaptionFormat{listing}{\parbox{\linewidth}{\colorbox{сaptionbk}{\parbox{\linewidth}{#1#2#3}}\vskip-4pt}}
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\renewcommand{\lstlistingname}{Листинг} % Переименование Listings в нужное именование структуры

%------------------------------------------------------------------------------
\begin{document}
\nocite{*}

\begin{titlepage}
\thispagestyle{empty}

\begin{center}
Санкт-Петербургский государственный политехнический университет \\
Институт Информационных Технологий и Управления \\*
Кафедра компьютерных систем и программных технологий \\*
\hrulefill
\end{center}

\vspace{18em}

\begin{center}
\Large Отчёт по практической работе\\ по предмету «Системное программное обеспечение» \\
\end{center}

\vspace{1em}

% \linebreak
\begin{center}
\textsc{\textbf{Утилита top}}
\end{center}

\vspace{16em}

\begin{flushleft}
Работу выполнил студент гр. 53501/3\hrulefill Мартынов С. А. \\
\vspace{1.5em}
Работу принял преподаватель \hrulefill Душутина Е. В. \\
\end{flushleft}

\vspace{\fill}

\begin{center}
Санкт-Петербург \\
2015
\end{center}

\end{titlepage}
%------------------------------------------------
\setcounter{page}{2}
\tableofcontents
%------------------------------------------------
\newpage
\section*{Постановка задачи}
\addcontentsline{toc}{section}{Постановка задачи}

В рамках данной работы необходимо ознакомиться с работой утилиты top. Рассмотреть и описать механизмы сбора информации, используемые системные вызовы и общий порядок функционирования утилиты.
\vspace{3em}

В работе необходимо указать источники и версии используемых программных продуктов.
\vspace{1em}

Показать пример доступа к proc в утилите.
\vspace{1em}

Привести отдельные собственные программные примеры доступа к proc (по чтению и записи посредством утилит и напрямую);
\vspace{1em}

Предложить модификацию утилиты дополнением информации о входящих потоках (нитях) в заданный в качестве параметра процесс, а также по ключу информации о потоках каждого процесса.
\vspace{1em}

Описать возможные способы получения и источники информации о потоках процесса, привести отдельные программные примеры (вне модифицированной утилиты) получения  информации о входящих потоках для процесса.
\vspace{1em}

Полные исходные коды сделать доступными по адресу \url{https://github.com/SemenMartynov/SPbPU_SystemProgramming}.

\newpage
%------------------------------------------------
\section*{Введение}
\addcontentsline{toc}{section}{Введение}

Работа выполняется под управлением Ubuntu 14.04.2 LTS. В качестве изучаемой утилиты используется реализация htop (автор Hisham H. Muhammad). Htop написан на языке Си и использует для отображения библиотеку Ncurses. Htop показывает динамический список системных процессов (рисунок 1), список обычно выравнивается по использованию ЦПУ. В отличие от top, htop показывает все процессы в системе. Также показывает время непрерывной работы, использование процессоров и памяти.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.65]{res/Htop}
\caption{Системный монитор htop}
\end{figure}

Рассматривается версия 1.0.3 (от 24 апреля 2014 года). Исходники доступны по лицензии GPL на сайте \url{http://hisham.hm/htop/}. Для простоты изучения, в код системы были внесены не значительные изменения.

\newpage
%------------------------------------------------
\section{Виртуальная файловая система procfs}

Файловая система /ргос содержит подробную информацию об активных процессах. Информация о процессе, сохраненная в файловой системе /ргос, изменяется по мере прохождения данным процессом его жизненного цикла.

Каждый элемент в каталоге /ргос - это десятичное число, соответствующее идентификатору какого-нибудь процесса. Каждый каталог в файловой системе /ргос содержит файлы с более подробной информацией о данном процессе. Владелец каждого файла в каталоге /ргос и его подкаталогах устанавливается по номеру идентификатора пользователя данного процесса.

Первоначально procfs была разработана для свободного получения  информации о состоянии процессов, теперь ее функции расширились, и через эту виртуальную файловую систему процессам можно передавать какие-то параметры (см. рис. 2).

\begin{figure}[h!]
\centering
\includegraphics[scale=0.9]{res/ProcessFileSystem}
\caption{Виртуальная файловая система procfs}
\end{figure}

Виртуальной она называется потому, что имеющиеся здесь файлы и каталоги на самом деле не находятся на жестком диске. После загрузки ядра они находятся в оперативной памяти. Для пользователя этот механизм полностью  прозрачен. Многие программы, в  том числе htop, собирают информацию из  файлов  в  /рrос, форматируют их и выводят результат.

В /рrос можно найти  также  информацию об установленном оборудовании,  разметке  жесткого диска, статистику и  многое другое.

При работе с /proc есть важный нюанс: информацию  из  файла можно прочитать, но открыть его в текстовом редакторе не получится, т.к. его содержимое может измениться в любую секунду. Для записи  и  считывания данных в  такой  файл используются утилиты, вроде cat и echo.

Файлы в  procfs могут иметь три варианта доступа:
\begin{itemize}
\item только для чтения — предназначены для получения информации об определенном параметре, при попытке в них что-то записать будет выдано предупреждение;
\item только для чтения пользователем root — такой же, как и предыдущий, но получить информацию может только администратор;
\item только для записи  пользователем root — позволяет не только считать данные, но и  изменить параметр.
\end{itemize}

Возможны и  некоторые комбинации  этих трех вариантов.  К тому же в  некоторые файлы можно записать только строго определенное значение.\cite{Yamchuk}

Утилита htop производит считывание различных параметров процессов. Далее будет рассмотрено как это происходит.

Просмотреть информацию о процессоре можно командой cat из файла /proc/cpuinfo. В моём случае это дало следующий результат (для отчёта вывод обрезан, т.к. повторяется по всем ядрам):

\begin{verbatim}
sam@spb:~$ cat /proc/cpuinfo 
processor	: 0
vendor_id	: GenuineIntel
cpu family	: 6
model		: 23
model name	: Intel(R) Core(TM)2 Quad CPU    Q8300  @ 2.50GHz
stepping	: 10
microcode	: 0xa0b
cpu MHz		: 1998.000
cache size	: 2048 KB
physical id	: 0
siblings	: 4
core id		: 0
cpu cores	: 4
apicid		: 0
initial apicid	: 0
fpu		: yes
fpu_exception	: yes
cpuid level	: 13
wp		: yes
flags		: fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat
 pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx lm constant_tsc
 arch_perfmon pebs bts rep_good nopl aperfmperf pni dtes64 monitor ds_cpl vmx est
 tm2 ssse3 cx16  xtpr pdcm sse4_1 xsave lahf_lm dtherm tpr_shadow vnmi flexpriority
bogomips	: 4991.93
clflush size	: 64
cache_alignment	: 64
address sizes	: 36 bits physical, 48 bits virtual
power management:
\end{verbatim}

А вот вывод информации о памяти

\begin{verbatim}
sam@spb:~$ cat /proc/meminfo 
MemTotal:        8176408 kB
MemFree:          391976 kB
Buffers:           39692 kB
Cached:           964508 kB
SwapCached:         1784 kB
Active:          1878368 kB
Inactive:        1060044 kB
Active(anon):    1528192 kB
Inactive(anon):   729880 kB
Active(file):     350176 kB
Inactive(file):   330164 kB
Unevictable:          32 kB
Mlocked:              32 kB
SwapTotal:       8387580 kB
SwapFree:        8359320 kB
Dirty:                 0 kB
Writeback:             0 kB
AnonPages:       1932372 kB
Mapped:          4824228 kB
Shmem:            323860 kB
Slab:             176288 kB
SReclaimable:     100712 kB
SUnreclaim:        75576 kB
KernelStack:        4568 kB
PageTables:        39424 kB
NFS_Unstable:          0 kB
Bounce:                0 kB
WritebackTmp:          0 kB
CommitLimit:    12475784 kB
Committed_AS:    9617760 kB
VmallocTotal:   34359738367 kB
VmallocUsed:      327844 kB
VmallocChunk:   34359407416 kB
HardwareCorrupted:     0 kB
AnonHugePages:    475136 kB
HugePages_Total:       0
HugePages_Free:        0
HugePages_Rsvd:        0
HugePages_Surp:        0
Hugepagesize:       2048 kB
DirectMap4k:     1467968 kB
DirectMap2M:     6920192 kB
\end{verbatim}

Следующий пример показывает как можно разрешить машине быть сетевым шлюзом для IPv6 соединений (параметр будет сброшен в 0 после перезагрузки):

\begin{verbatim}
sam@spb:~$ cat /proc/sys/net/ipv6/conf/all/forwarding
0
sam@spb:~$ echo "1" | sudo tee -a /proc/sys/net/ipv6/conf/all/forwarding
[sudo] password for sam: 
1
sam@spb:~$ cat /proc/sys/net/ipv6/conf/all/forwarding
1
sam@spb:~$
\end{verbatim}


\newpage
%------------------------------------------------
\section{Процессы}

Листинг 1 содержит отрывок файла Process.h, описывающий структуру Process. На самом деле этот отрезок короче, если учесть работу препроцессора, который содержит многие строки (отладочную информацию, данные OpenVZ и виртуального сервера).

\lstinputlisting[firstline=63,lastline=153,language=C++, caption={Клиент именованного каналов (src/top/Process.h)}]{../../src/top/Process.h}

Назначение большинства полей понятно исходя из их названий, и они здесь представлены для дальнейшего перехода к системам, которые заполняют значение этих полей (к примеру, процент занятой памяти или процессорного времени). Процессы объединяются в списки (строка 4), а объект Object (строка 2) отвечает за отображение. Полный граф взаимодействия структура данных представлен на рисунке 3.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{res/process.png}
\caption{Граф взаимодействия для структуры Process}
\end{figure}

На графе видно, что некоторые структуры, такие как CPUData\_ не связаны с конкретным процессом, и это логично, т.к. эта общесистемная информация, но к ней есть доступ через сам список. Структуры, такие как RitcString\_, Vector\_ и Hashtable\_ используются для служебных целей (сортировка списков, парсинг текстовой информации), т.к. программа написана на C (т.е. это реализация структур из C++, реализованная на языке С).

Все процессы помещаются в список, который, помимо самих процессоров, хранит ещё общесистемные показатели, такие как распределение памяти и ресурсов центрального процессора (листинг 2).

Получить показатели используемой памяти можно из файла /proc/meminfo (стр. 5 - макрос подставит правильный путь на место PROCMEMINFOFILE). В этой функции определяется следующие показатели памяти:
\begin{itemize}
\item общий объём памяти (стр 17);
\item объём свободной памяти (стр. 19);
\item объём памяти, разделяемой между процессами (стр. 21);
\item размер буферов (стр. 25);
\item размер кешей (стр.29);
\item общий объём, используемый для хранения страниц памяти на диске (стр. 33);
\item свободное место в свапе (стр. 35);
\item объём используемой памяти, как разность между общим объёмом и свободной памятью (стр. 41);
\item объём используемого места в свапе, как разность между общим объёмом и свободным пространством (стр. 42);
\end{itemize}

Помимо информации о памяти, тут же происходит считывание информации о прерываниях и операциях ввода-вывода из файла /proc/stat (стр. 45 - замена имени файла будет произведена препроцессором). из этого файла для каждого процессора (стр. 49) считываются следующие показатели:
\begin{itemize}
\item время, проведённое процессором в пространстве пользователя (стр. 83);
\item время, на выделение которого повлиял приоритет процесса (стр. 84);
\item время, проведённое процессором в пространстве ядра (стр. 85);
\item время, проведённое процессором в пространстве ядра, включая обработку прерываний (стр. 86);
\item время, проведённое процессором в режиме бездействия (стр. 87);
\item время, проведённое процессором в режиме бездействия, включая время ожидания выполнения операций ввода-вывода (стр. 88);
\item время ожидания выполнения операций ввода-вывода (стр. 89);
\item объём обработки прерываний (стр. 90);
\item объём обработки программных прерываний (стр. 91);
\item украденное время - характерно для гипервизоров (стр. 92);
\item время в режиме гостя - характерно для гипервизоров (стр. 93);
\item общее время работы процессора (стр. 94);

\item объём используемого места в свапе, как разность между общим объёмом и свободным пространством (стр. 42);
\end{itemize}

\lstinputlisting[firstline=765,lastline=897,language=C++, caption={Считывание различных общесистемных показателей(src/top/ProcessList.c)}]{../../src/top/ProcessList.c}

\newpage
%------------------------------------------------
\section{Измерение уровня заряда батарейки}

Листинг 3 содержит отрывок файла BatteryMeter.c, который содержит функционал для отображения информации об источнике питания.

Как видно в строке 18, информация о батарее находиться по пути /proc/acpi/battery. В этой директории должны находиться файлы, название которых начинается с букв BAT, и это сравнение производится в строке 38. Имена файлов складываются в односвязный список myList (стр. 44), для последующего перебора (стр. 48). В строке 53 формируется полный путь до файла, отображающего состояние батарейки и содержимое этого файла вычитывается в массив line (стр. 61). В этой строке производится смещение на количество символов, переданное в качестве параметра функции, а полученный результат провидится к числу и аккумулируется. Так собирается информация об общем объёме батареи и её состоянии (остатке заряда). Сбор осуществляет функция getProcBatData в стр. 186. Эта же функция определяет процент использования аккумулятора, путём деления остатка заряда на общий объём батареи (стр. 195).

Если источником питания является подключенный сетевой адаптер, то информация об этом может быть получена из /proc/acpi/ac\_adapter (стр. 84) или из /sys/class/power\_supply/ (стр. 132). В обоих случаях производится попытка чтения файла для определения активности адаптера. Этот вариант применим для ноутбуков, в моём случае обе директории оказались пусты.

В этом же файле представлен функционал для отслеживания подключения адаптера (в этот момент источник питания изменяется с батарейки на питание от электросети) или завершение зарядки аккумулятора. События мониторятся по пути /sys/class/power\_supply/ (стр. 220). Код в строке 228 и строке 240 во многом дублируются, т.к. в некоторых системах событие окончание зарядки содержит слово CHARGE, а в некоторых ENERGY. Обработка события происходит в функции из строки 1.

Источник питания может быть электросетью, а может быть аккумуляторной батареей, выводимый текст определяется в строке 275. Полный граф включения для файла BatteryMeter.c представлен на рисунке 4.

\newpage
\lstinputlisting[firstline=36,lastline=295,language=C++,caption={Battery Meter - измерение уровня заряда(src/top/BatteryMeter.c)}]{../../src/top/BatteryMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.45]{res/battery_meter.png}
\caption{Граф включения для файла BatteryMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Мониторинг времени}

Монитор времени отвечает за отображение текущего времени пользователя. Отрывок файла ClockMeter.c представлен в листинге 4 а граф включения на рисунке 5.

Интерес представляет только одна функция. Она берёт локальное время (стр. 3) и преобразует его к привычному виду (часы:минуты:секунды), сохраняя это преобразование в буфере, который является аргументом функции.

\lstinputlisting[firstline=22,lastline=28,language=C++, caption={Clock Meter - мониторинг времени(src/top/ClockMeter.c)}]{../../src/top/ClockMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.5]{res/clock_meter.png}
\caption{Граф включения для файла ClockMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Центральный процессор}

С оценкой потребления процессора всегда встает сложность разделения физических и логических ядер. В одном реальном процессоре может быть несколько ядер, каждое из которых может иметь дополнительный набор регистров, обеспечивающих hyper-threading.

Ранее мы рассматривали как происходит чтение информации об использовании процессора приложениями. Функция CPUMeter\_setValues из листинга 5 занимается подготовкой следующих полей\cite{HowTo}:
\begin{itemize}
\item nicePeriod (стр. 11) - означает процент CPU, используемого пользовательскими процессами, на которые повлияло использование команд nice или renice, т.е. по существу их приоритет был изменен по сравнению с приоритетом по умолчанию, назначаемому планировщиком, на более высокий или низкий. При назначении какому-либо процессу команды nice, положительное число означает более низкий приоритет (1 = 1 шаг ниже нормального), а отрицательное число означает более высокий приоритет. 0 -- значение по умолчанию, что означает, что решение о приоритете принимает планировщик. Можно установить, какой планировщик используется системой.
\item userPeriod (стр. 12) - оказывает использование отдельного процессора (пользовательскими процессами, такими, как apache, mysql и т.д.) до максимального значения, составляющего 100\%. Таким образом, если в четырехъядерном процессоре 1 процесс использует 100\% CPU, это даст значение \%us, равное 25\%. Значение 12,5\% для 8-ядерного процессора означает, что занято одно ядро.
\item systemPeriod (стр 14) - означает использование CPU системой. Обычно это значение невысоко, высокие его значения могут свидетельствовать о проблеме с конфигами ядра, проблему со стороны драйвера, или целый ряд других вещей.
\item irqPeriod (стр 15) - означает прерывания на уровне железа; на плате электроны движутся по микросхемам предсказуемым образом. Например, когда сетевая карта получает пакет, перед передачей информации, содержащейся в пакете в процессор через ядро, она запросит прерывание в канале прерывания материнской платы. Процессор сообщает ядру, что у сетевой карты для него есть информация, а ядро имеет возможность решить, как поступить. Высокое значение времени, тратящегося на обработку прерываний на уровне железа встречается на виртуальной машине довольно редко, но по мере того, как гипервизоры предоставляют в распоряжение виртуальных машин все больше «железа», эта ситуация может измениться. Чрезвычайно высокая пропускная способность сети, использование USB, вычисления на графических процессорах, -- все это может привести к росту этого параметра на величину, превышающую несколько процентов.
\item softIrqPeriod (стр 16) - прерывание на уровне софта; начиная с ядра linux версии 2.4 реализована возможность запроса прерывания программным обеспечением (приложениями), а не элементом аппаратного обеспечения или устройством (драйвером), запрашивающим прерывание в канале прерывания материнской платы; запрос обслуживается ядром посредством его обработчика прерываний. Это означает, что приложение может запросить приоритетный статус, ядро может подтвердить получение команда, а программное обеспечение будет терпеливо ждать, пока прерывание не будет обслужено. Если мы применим утилиту tcpdump к гигабитному каналу с высоким трафиком, то значение может измениться примерно на 10\%, -- по мере заполнения выделенной памяти tcpdump, утилита посылает зарос на прерывание, чтобы переместить данные со стека на диск, экран и т.д. 
\item ioWaitPeriod (стр 17) - процент времени (циклов, секунд), в течение которого процессор простаивал, ожидая завершения операции ввода-вывода. Когда какой-либо процесс или программа запрашивает данные, он сначала проверяет кэш процессора (в нем имеется 2 или 3 кэша), затем проверяет память и, наконец, доходит до диска. Дойдя до диска, процессу или программе обычно приходится ждать, пока поток ввода-вывода передаст информацию в оперативную память, прежде чем иметь возможность снова на нем работать. Чем медленнее диск, тем выше будет значение IO Wait \% для каждого процесса. Это происходит также с процессами записи на диск, если системный буфер заполнен и его необходимо прочистить при помощи ядра – обычно это наблюдается на серверах баз данных с высокой нагрузкой. Если значение IO Wait стабильно превышает {100 / (кол-во CPU * кол-во процессов)}\%, это означает, что, возможно, имеется проблема хранения, с которой необходимо разобраться. Если вы наблюдаете высокую среднюю нагрузку, прежде всего, проверьте этот параметр. Если он высок, тогда узкое место в процессах, скапливающихся на диске, а не в чем-либо еще.
\item stealPeriod (стр 18) - в виртуализированной среде множество логических серверов могут работать под одним фактическим гипервизором. Каждой виртуальной машине(VM) присваивается 4-8 "виртуальных" CPU; хотя сами гипервизоры могут не иметь (кол-во VM * кол-во виртуальных CPU на одну VM). Причина этого заключается в том, что мы не перегружаем CPU использованием виртуальных машин, так что если дать одной-двум VM возможность изредка использовать 8 процессоров, это не будет негативно влиять на весь пул в целом. Однако если виртуальными процессорами VM используется количество CPU, превышающее количество физических (или логических, в случае с гиперпотоковыми процессорами Xeon), тогда значение iosteal будет расти.
\item guestPeriod (стр 19) - параметр похож на предыдущий, но со стороны виртуальной машины.
\end{itemize}

Функция CPUMeter\_display (стр. 33) занимается оформленным выводом информации, которую мы описали выше. Граф включения представлен на рисунке 6.

\lstinputlisting[firstline=45,lastline=126,language=C++, caption={CPU Meter - центральный процессор(src/top/CPUMeter.c)}]{../../src/top/CPUMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.45]{res/cpu_meter.png}
\caption{Граф включения для файла CPUMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Имя устройства (хоста)}

Этот модуль является самым простым. Его работа сводится фактически к одной строке, которая записывает имя хоста в переданный буфер. Функция gethostname является стандартной (POSIX), и она определена в заголовочном файле unistd.h. Вызов этой функции обёрнут другой функцией HostnameMeter\_setValues, которая показана в листинге 5. Простота этой функции не отменяет её значимости, которая показана в графе включения на рисунке 7.

\lstinputlisting[firstline=22,lastline=25,language=C++, caption={Hostname Meter - имя устройства (хоста) (src/top/HostnameMeter.c)}]{../../src/top/HostnameMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{res/hostname_meter.png}
\caption{Граф включения для файла HostnameMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Измерение средней загрузки}

Большую часть задачи, как и раньше, берёт на себя ядро. В файловой системе proc оно создаёт файл loadavg. Этот файл состоит из пяти групп\cite{HowTo}:
\begin{itemize}
\item первое поле (число) — показывает использование процессора за последнюю минуту;
\item второе поле (число) — показывает использование процессора за последние пять минут;
\item третье поле (число) — показывает использование процессора за последние десять минут;
\item четвёртое поле (число/число) — состоит из двух значений, разделённых слешем, первая часть значения поля показывает количество выполняющихся в данный момент процессов/потоков (это значение не может быть больше количества присутствующих в системе CPU), вторая часть поля отображает количество процессов присутствующих в системе;
\item пятое поле (число) — хранит ID последнего запущенного в системе процесса (если для просмотра содержимого /proc/loadavg была использована команда cat, то будет значение PID именно программы cat).
\end{itemize}

В листинге 6 представлен отрывок файла LoadAverageMeter.c. Функция LoadAverageMeter\_scan (стр. 1) как раз обеспечивает открытие файла loadavg (стр. 4) и чтение пяти рассмотренных выше полей (стр. 6), при этом четвёртое поле читается как два различных числа.

Функция LoadAverageMeter\_setValues (стр. 14) обращается к LoadAverageMeter\_scan и сохраняет полученные значения по загрузке процессора за последнюю минуту, пять минут и десять минут в буфер (стр. 16), переданный в качестве аргумента.

Для отображения значений используется функция LoadAverageMeter\_display (стр 19). Она обеспечивает форматированный и цветной вывод для отображения загрузки процессора за последнюю минуту (стр. 22), пять минут (стр. 24) и десять минут (стр. 26).

Функции LoadMeter\_setValues (стр. 30) и LoadMeter\_display (стр 39) также обращаются к функции LoadAverageMeter\_scan, но они отображают только загрузку за последнюю минуту, для просмотра изменения загрузки в режиме (относительно) реального времени.

\newpage
\lstinputlisting[firstline=25,lastline=68,language=C++, caption={Load Average Meter - измерение средней загрузки (src/top/LoadAverageMeter.c)}]{../../src/top/LoadAverageMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.55]{res/load_average_meter.png}
\caption{Граф включения для файла LoadAverageMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Измерение уровня использования памяти}

Сбор различных характеристик системы уже был показан в листинге 2. В листинге 8 представлены две функции.

Функция MemoryMeter\_setValues (стр. 1) выводит в буфер следующую информацию:
\begin{itemize}
\item usedMem (стр. 2) - реально использующая в данный момент и зарезервированная системой память;
\item buffersMem (стр. 3) - буферы в памяти это страницы памяти, зарезервированные системой для выделения их процессам, когда они затребуют этого, так же известна как heap-memory;
\item cachedMem (стр. 4) - файлы, которые недавно были использованы системой/процессами и хранящиеся в памяти на случай если вскоре они снова потребуются.
\end{itemize}

Функция MemoryMeter\_display (стр. 13) занимается оформленным выводом собранной информации. Граф включения представлен на рисунке 9.

\lstinputlisting[firstline=28,lastline=60,language=C++, caption={Memory Meter - измерение уровня использования памяти (src/top/MemoryMeter.c)}]{../../src/top/MemoryMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.43]{res/memory_meter.png}
\caption{Граф включения для файла MemoryMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Измерение уровня использования области подкачки}

Если система приступает к запуску программу, которая требует больше оперативной памяти, чем доступно, то для решения этой задачи, используется технология swapping (”подкачка”). Суть этой технологии заключается в том, что некоторый объем данных (который не “помещается” в оперативную память) временно хранится на жестком диске, в то время как другая часть данных обрабатывается.

В Linux оперативная память делится на разделы, называемые страницами. Swapping (подкачка) – это процесс во время которого страницы памяти копируются на специально сконфигурированный для этого раздел диска, называемый swap space (раздел подкачки, может быть как и файлом, так и разделом жесткого диска), для освобождения ОЗУ. Совокупные размеры физической памяти и раздела подкачки – это объем имеющийся виртуальной памяти.

В листинге 2 мы рассматривали процедуру сбора системной информации, в листинге 9 нас интересуют три функции работы со свапом.

В функции SwapMeter\_humanNumber (стр. 2) размер раздела подкачки приводится к виду, легко воспринимаемому человеком. Если объём превышает 10 гигабайт, то число отображается как соответствующее количество гигабайт (стр 4). Если число превышает 10 мегабайт, то оно отображается как соответствующее количество мегабайт (стр 6). Если ни одно из предыдущих правил не сработало, то объём отображается в килобайтах (стр. 8).

Функция SwapMeter\_setValues (стр. 11) выводит информацию о подкачке в буфер, переданный в качестве параметра. Для этого используется общий объём свапа (стр. 13) и занятый объём (стр. 12).

Функция SwapMeter\_display (стр 18) обеспечивает форматированный вывод всей собранной информации. Граф включения представлен на рисунке 10.

\lstinputlisting[firstline=32,lastline=60,language=C++, caption={Swap Meter - измерение уровня использования области подкачки (src/top/SwapMeter.c)}]{../../src/top/SwapMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.43]{res/swap_meter.png}
\caption{Граф включения для файла SwapMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Мониторинг процессов}

Как мы уже говорили, все процессы представлены своей директорией в файловой системе proc. вывод этой информации можно изучить в листинге 10.

Функция TasksMeter\_setValues (стр. 1) занимается в выводом в буфер (стр. 5) информации о процессах. Этой информацией является общее количество процессов (стр. 3) и количество запущенных в данный момент процессов (стр. 4). Как мы говорили выше, количество запущенных процессов не может превышать количество процессоров.

Функция TasksMeter\_display (стр. 8) обеспечивает форматированный вывод информации о процессах. При этом стоит обратить внимание, что она выводит не только процессы пользователя (стр. 22) но и процессы ядра (стр. 28), которые могут заниматься, к примеру, управлением кэшами.

Граф включений представлен на рисунке 11.

\lstinputlisting[firstline=21,lastline=56,language=C++, caption={Tasks Meter - мониторинг процессов (src/top/TasksMeter.c)}]{../../src/top/TasksMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{res/tasks_meter.png}
\caption{Граф включения для файла TasksMeter.c}
\end{figure}

\newpage
%------------------------------------------------
\section{Измерение времени работы системы}

Время работы системы также хранится в файловой системе proc в файле uptime. В листинге 11 представлена функция UptimeMeter\_setValues (стр. 1), которая открывает этот файл (стр. 3) и считывает оттуда значение (стр. 5). Стоит отметить, что на самом деле в этом файле хранится два числа.

\begin{itemize}
\item первое показывает количество секунд, прошедших с момента включения компьютера (это значение используется в дальнейшем)
\item второе показывает количество времени (тоже в секундах), которое система провела в бездействии (в т.ч. ожидая завершения операций ввода-вывода); на многоядерных системах это число складывается из времени бездействия каждого ядра, так что второе число по значению может обогнать первое.
\end{itemize}

Число секунд с момента включения приводится к виду, удобному для человеческого восприятия - в буфер выводится (стр. 27) количество дней, часов, минут и секунд работы.

\lstinputlisting[firstline=24,lastline=51,language=C++, caption={Uptime Meter - измерение времени работы системы (src/top/UptimeMeter.c)}]{../../src/top/UptimeMeter.c}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.6]{res/uptime_meter.png}
\caption{Граф включения для файла UptimeMeter.c}
\end{figure}

\newpage%------------------------------------------------
\section{Модификация для работы с процессом}

Как уже говорилось во введении, на верхнем уровне процессы представляют собой директории, именованные в соответствии с их pid. Рассмотрим, какую информацию можно получить из файловой системы proc, а потом добавим рассматриваемой утилите возможность работать с процессом, переданным в качестве параметра по его pid.

Некоторые файлы и директории из ProcFS\cite{HowTo}:
\begin{itemize}
\item /proc/PID/cmdline – аргументы командной строки (где PID – идентификатор процесса или self);
\item /proc/PID/environ – переменные окружения для данного процесса;
\item /proc/PID/status – статус процесса;
\item /proc/PID/fd – директория, содержащая символьные ссылки на каждый открытый файловый дескриптор;
\item /proc/cpuinfo – информация о процессоре (производитель, модель, поколение и т.п.);
\item /proc/cmdline – параметры, передаваемые ядру при загрузке;
\item /proc/uptime – количество секунд, прошедших с момента загрузки ядра и проведенных в режиме бездействия;
\item /proc/version – содержит информацию о версии ядра, компилятора и другую информацию, связанную с загруженным ядром.
\end{itemize}

Приведём несколько примеров использования procfs.

Следующая команда демонстрирует, как из procfs можно получить информацию о текущей рабочей директории процесса (3165 — номер pid’a процесса)

\begin{verbatim}
# ls -la /proc/3165/cwd
lrwxrwxrwx 1 clamav clamav 0 Авг 18 16:07 /proc/3165/cwd -> /var/lib/clamav
\end{verbatim}

Далее, можно вывести все переменные процесса

\begin{verbatim}
# cat /proc/3165/environ | strings
ReceiveTimeout=30
CONSOLE=/dev/console
SELINUX_INIT=YES
TERM=linux
rootmnt=/root
PidFile=/var/run/clamav/freshclam.pid
NotifyClamd=/etc/clamav/clamd.conf
LogTime=no
INIT_VERSION=sysvinit-2.86
init=/sbin/init
DNSDatabaseInfo=current.cvd.clamav.net
AllowSupplementaryGroups=false
PATH=/sbin:/usr/sbin:/bin:/usr/bin
LogSyslog=false
DatabaseMirror=database.clamav.net db.local.clamav.net
runlevel=2
RUNLEVEL=2
PWD=/
VERBOSE=no
DatabaseOwner=clamav
CompressLocalDatabase=no
previous=N
PREVLEVEL=N
LogVerbose=false
MaxAttempts=5
ScriptedUpdates=yes
Foreground=false
Checks=24
SHLVL=3
HOME=/
DatabaseDirectory=/var/lib/clamav/
LogFacility=LOG_LOCAL6
UpdateLogFile=/var/log/clamav/freshclam.log
LogFileMaxSize=0
ConnectTimeout=30
Debug=false
_=/sbin/start-stop-daemon
\end{verbatim}

Теперь можно получить статистику процесса
\begin{verbatim}
$ cat /proc/1742/status
Name:   bash
State:  S (sleeping)
Tgid:   3515
Pid:    3515
PPid:   3452
TracerPid:      0
Uid:    1000    1000    1000    1000
Gid:    100     100     100     100
FDSize: 256
Groups: 16 33 100
VmPeak:     9136 kB
VmSize:     7896 kB
VmLck:         0 kB
VmHWM:      7572 kB
VmRSS:      6316 kB
VmData:     5224 kB
VmStk:        88 kB
VmExe:       572 kB
VmLib:      1708 kB
VmPTE:        20 kB
Threads:        1
SigQ:   0/3067
SigPnd: 0000000000000000
ShdPnd: 0000000000000000
SigBlk: 0000000000010000
SigIgn: 0000000000384004
SigCgt: 000000004b813efb
CapInh: 0000000000000000
CapPrm: 0000000000000000
CapEff: 0000000000000000
CapBnd: ffffffffffffffff
Cpus_allowed:   00000001
Cpus_allowed_list:      0
Mems_allowed:   1
Mems_allowed_list:      0
voluntary_ctxt_switches:        150
nonvoluntary_ctxt_switches:     545
\end{verbatim}

Самое полезное в данном выводе, это поле Threads. Оно показывает количество потоков у процесса (ещё эту информацию можно получить через утилиту ps)\cite{Arnold}. Теперь остаётся внести изменения в исследуемую утилиту.

Поле с потоками называется NLWP (Number of Light-Weight Processes). Это название пошло со времён ОС Солярис.

Для работы этого функционала в структуре ProcessList\_ (объявлена в заголовочном файле Process.h) объявлена переменная nlwp типа long int (см. стр. 33 в листинге 1). Чтение из status-файла происходит в функции ProcessList\_readStatFile, листинг которой представлен в листинге 12.

\lstinputlisting[firstline=386,lastline=426,language=C++, caption={Чтение stat-файла процесса (src/top/ProcessList.c)}]{../../src/top/ProcessList.c}

Функция получает путь к proc (dirname) и номер процесса (name) в качестве параметров, из которых складывается полный путь к stat-файлу (стр 3). Этот файл открывается на чтение (стр стр. 4) и после некоторых проверок из него выбираются значения, в т.ч. количество процессов (стр. 37).



Запуск модифицированной версии, для отслеживания потоков firefox
\begin{verbatim}
sam@spb:~/tmp/top$ ./top --pid 19771
\end{verbatim}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{res/NLWP.png}
\caption{Количество потоков у процесса с pid 19771}
\end{figure}

\newpage
%------------------------------------------------
\section*{Заключение}
\addcontentsline{toc}{section}{Заключение}

В данной работе нами была изучена программа htop, являющееся расширенной версией стандартной утилиты top. Мы выпустили из рассмотрения особенности, связанные с графическим выводом (на базе библиотеки ncurces), сосредоточившись на основных функциональных возможностях.

Изучив исходный код, мы убедились, что никакие специальные системные вызовы утилита не использует, только самые широко распространённы, вроде чтения из файла и вывод на экран (но они используются так часто, что их систематизация для данного отчёта оказалась крайне затруднительной).

Основным выводом является тот факт, что в отличии от Windows, Linux предоставляет удобный механизм сбора системной информации через файловую систему proc, который активно используется утилитами вроде ps, htop (стр. 5 листинг 2; стр. 18 листинг 3; стр. 136 листинг 3; стр. 201 листинг 3; стр. 4 листинг 7; стр. 3 листинг 11; стр. 26 листинг 13).

Файловая система proc обладает обширными возможностями по конфигурированию linux, в то же время её использование требует предельной осторожности, так как попытка записи в некоторые файлы может повредить файловую систему или привести к краху системы.

\newpage
%------------------------------------------------
\section*{}
\addcontentsline{toc}{section}{Список литературы}

\begin{thebibliography}{00}

\bibitem{Yamchuk}Яремчук С. А.  Linux Mint на 100 \%. -- СПб.: Питер, 2011. -- 240 е.: ил. — (Серия «На 100 \%»). ISBN: 978-5-49807-803-8.

\bibitem{HowTo}HowTo: Troubleshoot with linux 'top' command. David Van Rood (dowdandassociates.com). 

\bibitem{Arnold} Арнольд Роббинс. Linux. Программирование в примерах -- СПб.: КУДИЦ-Пресс, 2006 -- 256 стр.

\end{thebibliography}

\end{document}
