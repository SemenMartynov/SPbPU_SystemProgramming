\documentclass[a4paper, 12pt]{report}		% general format

%%%% Charset
\usepackage{cmap}							% make PDF files searchable and copyable
\usepackage[utf8]{inputenc}					% accept different input encodings
\usepackage[T2A]{fontenc}					% russian font
\usepackage[russian]{babel}					% multilingual support (T2A)

%%%% Graphics
\usepackage[dvipsnames]{xcolor}			% driver-independent color extensions
\usepackage{graphicx}						% enhanced support for graphics
\usepackage{wrapfig}						% pro­duces fig­ures which text can flow around

%%%% Math
\usepackage{amsmath}						% Amer­i­can Math­e­mat­i­cal So­ci­ety (AMS) math fa­cil­i­ties
\usepackage{amsfonts}						% fonts from the AMS
\usepackage{amssymb}						% additional math symbols

%%%% Ty­po­grapy (don't forget about cm-super)
\usepackage{microtype}						% sublim­i­nal re­fine­ments to­wards ty­po­graph­i­cal per­fec­tion
\linespread{1.3}							% line spacing
\usepackage[left=2.5cm, right=1.5cm, top=2.5cm, bottom=2.5cm]{geometry}
\setlength{\parindent}{0pt}					% we don't want any paragraph indentation
\renewcommand{\chaptername}{}

%%%% Other
\usepackage{url}							% ver­ba­tim with URL-sen­si­tive line breaks
%\DeclareUnicodeCharacter{00A0}{~}

%------------------------------------------------------------------------------
\usepackage{listings}						% type­set source code list­ings

% Цвета для кода
\definecolor{string}{HTML}{101AF9}			% цвет строк в коде
\definecolor{comment}{HTML}{0C2612}		% цвет комментариев в коде
\definecolor{keyword}{HTML}{5F1441}		% цвет ключевых слов в коде
\definecolor{morecomment}{HTML}{8000FF}	% цвет include и других элементов в коде
\definecolor{captiontext}{HTML}{FFFFFF}	% цвет текста заголовка в коде
\definecolor{captionbk}{HTML}{999999}		% цвет фона заголовка в коде
\definecolor{bk}{HTML}{FFFFFF}				% цвет фона в коде
\definecolor{frame}{HTML}{999999}			% цвет рамки в коде

% Настройки отображения кода
\lstset{
	language=C++,							% Язык кода по умолчанию
	morekeywords={*,...},					% если хотите добавить ключевые слова, то добавляйте
	% Цвета
	keywordstyle=\color{keyword}\ttfamily\bfseries,
	stringstyle=\color{string}\ttfamily,
	commentstyle=\color{comment}\ttfamily\itshape,
	morecomment=[l][\color{morecomment}]{\#},
	% Настройки отображения
	breaklines=true,						% Перенос длинных строк
	basicstyle=\ttfamily\footnotesize,		% Шрифт для отображения кода
	backgroundcolor=\color{bk},				% Цвет фона кода
	%frame=lrb,xleftmargin=\fboxsep,xrightmargin=-\fboxsep, % Рамка, подогнанная к заголовку
	frame=tblr								% draw a frame at all sides of the code block
	rulecolor=\color{frame},				% Цвет рамки
	tabsize=2,								% tab space width
	showstringspaces=false,					% don't mark spaces in strings
	% Настройка отображения номеров строк. Если не нужно, то удалите весь блок
	numbers=left,							% Слева отображаются номера строк
	stepnumber=1,							% Каждую строку нумеровать
	numbersep=5pt,							% Отступ от кода
	numberstyle=\small\color{black},		% Стиль написания номеров строк
	% Для отображения русского языка
	extendedchars=true,
	literate={Ö}{{\"O}}1
	 	{Ä}{{\"A}}1
	 	{Ü}{{\"U}}1
		{ß}{{\ss}}1
		{ü}{{\"u}}1
		{ä}{{\"a}}1
		{ö}{{\"o}}1
		{~}{{\textasciitilde}}1
		{а}{{\selectfont\char224}}1
		{б}{{\selectfont\char225}}1
		{в}{{\selectfont\char226}}1
		{г}{{\selectfont\char227}}1
		{д}{{\selectfont\char228}}1
		{е}{{\selectfont\char229}}1
		{ё}{{\"e}}1
		{ж}{{\selectfont\char230}}1
		{з}{{\selectfont\char231}}1
		{и}{{\selectfont\char232}}1
		{й}{{\selectfont\char233}}1
		{к}{{\selectfont\char234}}1
		{л}{{\selectfont\char235}}1
		{м}{{\selectfont\char236}}1
		{н}{{\selectfont\char237}}1
		{о}{{\selectfont\char238}}1
		{п}{{\selectfont\char239}}1
		{р}{{\selectfont\char240}}1
		{с}{{\selectfont\char241}}1
		{т}{{\selectfont\char242}}1
		{у}{{\selectfont\char243}}1
		{ф}{{\selectfont\char244}}1
		{х}{{\selectfont\char245}}1
		{ц}{{\selectfont\char246}}1
		{ч}{{\selectfont\char247}}1
		{ш}{{\selectfont\char248}}1
		{щ}{{\selectfont\char249}}1
		{ъ}{{\selectfont\char250}}1
		{ы}{{\selectfont\char251}}1
		{ь}{{\selectfont\char252}}1
		{э}{{\selectfont\char253}}1
		{ю}{{\selectfont\char254}}1
		{я}{{\selectfont\char255}}1
		{А}{{\selectfont\char192}}1
		{Б}{{\selectfont\char193}}1
		{В}{{\selectfont\char194}}1
		{Г}{{\selectfont\char195}}1
		{Д}{{\selectfont\char196}}1
		{Е}{{\selectfont\char197}}1
		{Ё}{{\"E}}1
		{Ж}{{\selectfont\char198}}1
		{З}{{\selectfont\char199}}1
		{И}{{\selectfont\char200}}1
		{Й}{{\selectfont\char201}}1
		{К}{{\selectfont\char202}}1
		{Л}{{\selectfont\char203}}1
		{М}{{\selectfont\char204}}1
		{Н}{{\selectfont\char205}}1
		{О}{{\selectfont\char206}}1
		{П}{{\selectfont\char207}}1
		{Р}{{\selectfont\char208}}1
		{С}{{\selectfont\char209}}1
		{Т}{{\selectfont\char210}}1
		{У}{{\selectfont\char211}}1
		{Ф}{{\selectfont\char212}}1
		{Х}{{\selectfont\char213}}1
		{Ц}{{\selectfont\char214}}1
		{Ч}{{\selectfont\char215}}1
		{Ш}{{\selectfont\char216}}1
		{Щ}{{\selectfont\char217}}1
		{Ъ}{{\selectfont\char218}}1
		{Ы}{{\selectfont\char219}}1
		{Ь}{{\selectfont\char220}}1
		{Э}{{\selectfont\char221}}1
		{Ю}{{\selectfont\char222}}1
		{Я}{{\selectfont\char223}}1
		{і}{{\selectfont\char105}}1
		{ї}{{\selectfont\char168}}1
		{є}{{\selectfont\char185}}1
		{ґ}{{\selectfont\char160}}1
		{І}{{\selectfont\char73}}1
		{Ї}{{\selectfont\char136}}1
		{Є}{{\selectfont\char153}}1
		{Ґ}{{\selectfont\char128}}1
}

% Для настройки заголовка кода
\usepackage{caption}
\DeclareCaptionFont{white}{\color{сaptiontext}}
\DeclareCaptionFormat{listing}{\parbox{\linewidth}{\colorbox{сaptionbk}{\parbox{\linewidth}{#1#2#3}}\vskip-4pt}}
%\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}
\renewcommand{\lstlistingname}{Листинг} % Переименование Listings в нужное именование структуры

%------------------------------------------------------------------------------
\begin{document}

\begin{titlepage}
\thispagestyle{empty}

\begin{center}
Санкт-Петербургский государственный политехнический университет \\
Институт Информационных Технологий и Управления \\*
Кафедра компьютерных систем и программных технологий \\*
\hrulefill
\end{center}

\vspace{18em}

\begin{center}
\Large Отчет по расчетной работе № 2 \\ по предмету «Системное программное обеспечение» \\
\end{center}

\vspace{1em}

% \linebreak
\begin{center}
\textsc{\textbf{Обработка исключений в ОС Windows}}
\end{center}

\vspace{16em}

\begin{flushleft}
Работу выполнил студент гр. 53501/3\hrulefill Мартынов С. А. \\
\vspace{1.5em}
Работу принял преподаватель \hrulefill Душутина Е. В. \\
\end{flushleft}

\vspace{\fill}

\begin{center}
Санкт-Петербург \\
2014
\end{center}

\end{titlepage}
%------------------------------------------------
\setcounter{page}{2}
\tableofcontents
%------------------------------------------------

\chapter*{Постановка задачи}
\addcontentsline{toc}{chapter}{Постановка задачи}

В рамках данной работы необходимо ознакомиться с основными механизмами межпроцессное взаимодействие в ОС Windows
\begin{enumerate}
    \item Анонимные каналы;
    \item Именованные каналы \\
        (локальная/сетевая реализация);
    \item Почтовые ящики;
    \item Shared memory;
    \item Сокеты;
    \item Порты завершения;
    \item Сигналы.
\end{enumerate}

В процессе изучения предполагается разработать простой (консольный) мгновенный обмен сообщениями.

Для тестирования сетевых реализаций используются два виртуальные машины (Win7) под управлением гипервизора VirtualBox. Сетевое подключение осуществляется в режиме bridge. Топология представлена на рисунке 1. Разницы между виртуальной и физической средой быть не должно.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.7]{img/01_topology}
\caption{Топология сети.}
\end{figure}

\vspace{1em}
Все результаты, представленные в данном отчёте получены с использованием Microsoft Windows 7 Ultimate Service Pack 1 64-bit (build 7601). Для разработки использовалась Microsoft Visual Studio Express 2013 for Windows Desktops (Version 12.0.30723.00 Update 3). В качестве отладчика использовался Microsoft WinDbg (release 6.3.9600.16384).

\vspace{1em}
Исходный код всех представленных листингов доступен по адресу \\ \url{https://github.com/SemenMartynov/SPbPU_SystemProgramming}.

\setcounter{page}{2}

%------------------------------------------------
\chapter*{Анонимные каналы}
\addcontentsline{toc}{chapter}{Анонимные каналы}

Анонимные каналы (anonymous channels) Windows обеспечивают однонаправленное (полудуплексное) посимвольное межпроцессное взаимодействие. Каждый канал имеет два дескриптора: дескриптор чтения (read handle) и дескриптор записи (write handle). Функция, с помощью которой создаются анонимные каналы, имеет следующий прототип:

\begin{verbatim}
BOOL CreatePipe(PHANDLE phRead, PHANDLE phWrite,
                                  LPSECURITY_ATTRIBUTES lpsa, DWORD cbPipe)
\end{verbatim}

Дескрипторы каналов часто бывают наследуемыми; причины этого станут понятными из приведенного ниже примера. Значение параметра cbPipe, указывающее размер канала в байтах, носит рекомендательный характер, причем значению 0 соответствует размер канала по умолчанию.

Чтобы канал можно было использовать для IPC, должен существовать еще один процесс, и для этого процесса требуется один из дескрипторов канала. Предположим, например, что родительскому процессу, вызвавшему функцию CreatePipe, необходимо вывести данные, которые нужны дочернему процессу. Тогда возникает вопрос о том, как передать дочернему процессу дескриптор чтения (phRead). Родительский процесс осуществляет это, устанавливая дескриптор стандартного ввода в структуре STARTUPINFO для дочерней процедуры равным *phRead.

Чтение с использованием дескриптора чтения канала блокируется, если канал пуст. В противном случае в процессе чтения будет воспринято столько байтов, сколько имеется в канале, вплоть до количества, указанного при вызове функции ReadFile. Операция записи в заполненный канал, которая выполняется с использованием буфера в памяти, также будет блокирована.

Наконец, анонимные каналы обеспечивают только однонаправленное взаимодействие. Для двухстороннего взаимодействия необходимы два канала.

В листинге 1 Представлен сервер, а в листинге 2 клиент для работы с анонимными каналами Windows. В программе используется передача дескрипторов через наследование. Рисунок 2 показывает результат работы.

\lstinputlisting[language=C++, caption={Сервер анонимных каналов}]
{../../InterProcessCommunication/AnonymousPipeServer/main.cpp}

\vspace{3em}

\lstinputlisting[language=C++, caption={Клиент анонимных каналов}]
{../../InterProcessCommunication/AnonymousPipeClient/main.cpp}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.95]{img/02_anonymous_channels}
\caption{Работа с анонимными каналами.}
\end{figure}

%------------------------------------------------
\chapter*{Именованные каналы}
\addcontentsline{toc}{chapter}{Именованные каналы}

Именованные каналы (named pipes) предлагают ряд возможностей, которые делают их полезными в качестве универсального механизма реализации приложений на основе IPC, включая приложения, требующие сетевого доступа к файлам, и клиент-серверные системы, хотя для реализации простых вариантов IPC, ориентированных на байтовые потоки, как в предыдущем примере, в котором взаимодействие процессов ограничивается рамками одной системы, анонимных каналов вам будет вполне достаточно. К числу упомянутых возможностей (часть которых обеспечивается дополнительно) относятся следующие:

\begin{itemize}
\item Именованные каналы ориентированы на обмен сообщениями, поэтому процесс, выполняющий чтение, может считывать сообщения переменной длины именно в том виде, в каком они были посланы процессом, выполняющим запись.

\item Именованные каналы являются двунаправленными, что позволяет осуществлять обмен сообщениями между двумя процессами посредством единственного канала.

\item Допускается существование нескольких независимых экземпляров канала, имеющих одинаковые имена. Например, с единственной серверной системой могут связываться одновременно несколько клиентов, использующих каналы с одним и тем же именем. Каждый клиент может иметь собственный экземпляр именованного канала, и сервер может использовать этот же канал для отправки ответа клиенту.

\item Каждая из систем, подключенных к сети, может обратиться к каналу, используя его имя. Взаимодействие посредством именованного канала осуществляется одинаковым образом для процессов, выполняющихся как на одной и той же, так и на разных машинах.

\item Имеется несколько вспомогательных и связных функций, упрощающих обслуживание взаимодействия "запрос/ответ" и клиент-серверных соединений.
\end{itemize}

Как правило, именованные каналы являются более предпочтительными по сравнению с анонимными, хотя существуют ситуации, когда анонимные каналы оказываются исключительно полезными. Во всех случаях, когда требуется, чтобы канал связи был двунаправленным, ориентированным на обмен сообщениями или доступным для нескольких клиентских процессов, следует применять именованные каналы. Попытки реализации последующих примеров с использованием анонимных каналов натолкнулись бы на значительные трудности.

Листинг 3 содержит код, реализующий сервер именованного канала. В листинге 4 - код клиента. Рисунок 3 - результат работы одного сервера с несколькими клиентами. Сервер не содержит разделяемых ресурсов, следовательно в средствах синхронизации потоков необходимости нет.

%\lstinputlisting[language=C++, caption={Клиент именованного каналов}]
%{../../InterProcessCommunication/NamedPipeClient/main.cpp}

\vspace{3em}

%\lstinputlisting[language=C++, caption={Клиент именованного каналов}]
%{../../InterProcessCommunication/NamedPipeClient/main.cpp}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{img/03_named_pipes}
\caption{Работа с нескольких клиентов с одним сервером по именованному каналу.}
\end{figure}

Помимо локального обмена, именованные каналы могут использоваться и для сетевого взаимодействия. Это требует не большой доработки клиента в части указания пути к каналу и изменения настроек безопасности. В листинге 5 содержится отрывок кода клиента с самыми значительными изменениями. Результаты работы внешне не отличаются от работы в локальном варианте.

%------------------------------------------------
\chapter*{Почтовые ящики}
\addcontentsline{toc}{chapter}{Почтовые ящики}

Как и именованные каналы, почтовые ящики (mailslots) Windows снабжаются именами, которые могут быть использованы для обеспечения взаимодействия между независимыми каналами. Почтовые ящики представляют собой широковещательный механизм, и ведут себя иначе по сравнению с именованными каналами, что делает их весьма полезными в ряде ограниченных ситуаций, которые, тем не менее, представляют большой интерес. Из наиболее важных свойств почтовых ящиков можно отметить следующие:

\begin{itemize}
\item Почтовые ящики являются однонаправленными.

\item С одним почтовым ящиком могут быть связаны несколько записывающих программ (writers) и несколько считывающих программ (readers), но они часто связаны между собой отношениями "один ко многим" в той или иной форме.

\item Записывающей программе (клиенту) не известно достоверно, все ли, только некоторые или какая-то одна из программ считывания (сервер) получили сообщение.

\item Почтовые ящики могут находиться в любом месте сети.

\item Размер сообщений ограничен.
\end{itemize}

Использование почтовых ящиков требует выполнения следующих операций:
\begin{itemize}
\item Каждый сервер создает дескриптор почтового ящика с помощью функции CreateMailSlot.

\item После этого сервер ожидает получения почтового сообщения, используя функцию ReadFile.

\item Клиент, обладающий только правами записи, должен открыть почтовый ящик, вызвав функцию CreateFile, и записать сообщения, используя функцию WriteFile. В случае отсутствия ожидающих программ считывания попытка открытия почтового ящика завершится ошибкой (наподобие "имя не найдено").
\end{itemize}

Сообщение клиента может быть прочитано всеми серверами; все серверы получают одно и то же сообщение.

Существует еще одна возможность. В вызове функции CreateFile клиент может указать имя почтового ящика в следующем виде:

\begin{verbatim}
\\*\mailslot\mailslotname
\end{verbatim}

При этом символ звездочки (*) действует в качестве группового символа (wildcard), и клиент может обнаружить любой сервер в пределах имени домена — группы систем, объединенных общим именем, которое назначается администратором сети. 

Листинг 6 и 7 демонстрируют реализацию приложения, иллюстрирующую обмен информацией почтовыми слотами. В процессе экспериментов было протестировано локальное, сетевое взаимодействие. Для широковещательной передач сообщений, адрес заменялся символом звездочки (*).

Листинг 6. Реализация серверной части почтового ящика.

\vspace{3em}

Листинг 7. Реализация клиентской части почтового ящика.

\begin{figure}[h!]
\centering
\includegraphics[scale=0.95]{img/04_MailSlot}
\caption{Работа почтовыми ящиками.}
\end{figure}

%------------------------------------------------
\chapter*{Shared memory}
\addcontentsline{toc}{chapter}{Shared memory}

Этот способ взаимодействия реализуется через технологию File Mapping - отображения файлов на оперативную память. Механизм позволяет осуществлять доступ к файлу таким образом, как будто это обыкновенный массив, хранящийся в памяти (не загружая файл в память явно). Можно создать объект file mapping, но не ассоциировать его с каким-то конкретным файлом. Получаемая область памяти будет общей между процессами. Работая с этой памятью, потоки обязательно должны согласовывать свои действия с помощью объектов синхронизации.

В листинге 8 и 9 представлен код двух программ, одна из которых генерирует случайные числа, а другая их читает и выводит на экран. Взаимодействие осуществляется через разделяемую память, защищённую мьютексом. Рисунок 5 показывает результат такого взаимодействия.

\begin{verbatim}
Листинг 8. Программа, генерирующая случайные числа в разделяемую память.

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#define BUF_SIZE 256
TCHAR szName[] = TEXT("MyFileMappingObject");
TCHAR szMsg[] = TEXT("Message from first process");
HANDLE mutex;
void main()
{
    HANDLE hMapFile;
    LPCTSTR pBuf;
    mutex = CreateMutex(NULL, false, TEXT("SyncMutex"));
    // create a memory, wicth two proccess will be working
    hMapFile = CreateFileMapping(
        // использование файла подкачки
        INVALID_HANDLE_VALUE,
        // защита по умолчанию
        NULL,
        // доступ к чтению/записи
        PAGE_READWRITE,
        // макс. размер объекта
        0,
        // размер буфера
        BUF_SIZE,
        // имя отраженного в памяти объекта
        szName);

    if (hMapFile == NULL || hMapFile == INVALID_HANDLE_VALUE)
    {
        printf("Не может создать отраженный в памяти объект (%d).\n",
            GetLastError());
        return;
    }
    pBuf = (LPTSTR)MapViewOfFile(
        //дескриптор проецируемого в памяти объекта
        hMapFile,
        // разрешение чтения/записи(режим доступа)
        FILE_MAP_ALL_ACCESS,
        //Старшее слово смещения файла, где начинается отображение
        0,
        //Младшее слово смещения файла, где начинается отображение
        0,
        //Число отображаемых байтов файла
        BUF_SIZE);
    
    if (pBuf == NULL)
    {
        printf("Представление проецированного файла невозможно (%d).\n",
            GetLastError());
        return;
    }

    int i = 0;
    while (true)
    {
        i = rand();
        itoa(i, (char *)szMsg, 10);
        WaitForSingleObject(mutex, INFINITE);
        CopyMemory((PVOID)pBuf, szMsg, sizeof(szMsg));
        printf("write message: %s\n", (char *)pBuf);
        //необходимо только для отладки - для удобства представления и анализа
        Sleep(1000);
        //результатов
        ReleaseMutex(mutex);
    }
    // освобождение памяти и закрытие описателя handle
    UnmapViewOfFile(pBuf);
    CloseHandle(hMapFile);
    CloseHandle(mutex);
}
\end{verbatim}

\vspace{3em}

\begin{verbatim}
Листинг 9. Программа, читающая случайные числа из разделяемой памяти.

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#define BUF_SIZE 256
#define TIME 15
// number of reading operation in this process
TCHAR szName[] = TEXT("MyFileMappingObject");
HANDLE mutex;
void main()
{
    HANDLE hMapFile;
    LPCTSTR pBuf;
    mutex = OpenMutex(
        // request full access
        MUTEX_ALL_ACCESS,
        // handle not inheritable
        FALSE,
        // object name
        TEXT("SyncMutex"));
    if (mutex == NULL)
        printf("OpenMutex error: %d\n", GetLastError());
    else printf("OpenMutex successfully opened the mutex.\n");
    hMapFile = OpenFileMapping(
        // доступ к чтению/записи
        FILE_MAP_ALL_ACCESS,
        // имя не наследуется
        FALSE,
        // имя "проецируемого " объекта
        szName);
    if (hMapFile == NULL)
    {
        printf("Невозможно открыть объект проекция файла (%d).\n", GetLastError());
        return;
    }
    pBuf = (LPTSTR)MapViewOfFile(hMapFile,
        // дескриптор "проецируемого" объекта
        FILE_MAP_ALL_ACCESS, // разрешение чтения/записи
        0,
        0,
        BUF_SIZE);
    if (pBuf == NULL)
    {
        printf("Представление проецированного файла (%d) невозможно .\n",
            GetLastError());
        return;
    }
    for (int i = 0; i < TIME; i++)
    {
        WaitForSingleObject(mutex, INFINITE);
        printf("read message: %s\n", (char *)pBuf);
        ReleaseMutex(mutex);
    }
    UnmapViewOfFile(pBuf);
    CloseHandle(hMapFile);
}

\end{verbatim}

\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{img/05_Sharedmemory}
\caption{Работа с разделяемой памятью.}
\end{figure}

%------------------------------------------------
\chapter*{Сокеты}
\addcontentsline{toc}{chapter}{Сокеты}

Winsock API разрабатывался как расширение Berkley Sockets API для среды Windows и поэтому поддерживается всеми системами Windows. К преимуществам Winsock можно отнести следующее:

\begin{itemize}
\item Перенос уже имеющегося кода, написанного для Berkeley Sockets API, осуществляется непосредственно.

\item Системы Windows легко встраиваются в сети, использующие как версию IPv4 протокола TCP/IP, так и постепенно распространяющуюся версию IPv6. Помимо всего остального, версия IPv6 допускает использование более длинных IP-адресов, преодолевая существующий 4-байтовый адресный барьер версии IPv4.

\item Сокеты могут использоваться совместно с перекрывающимся вводом/выводом Windows (глава 14), что, помимо всего прочего, обеспечивает возможность масштабирования серверов при увеличении количества активных клиентов.

\item Сокеты можно рассматривать как дескрипторы (типа HANDLE) файлов при использовании функций ReadFile и WriteFile и, с некоторыми ограничениями, при использовании других функций, точно так же, как в качестве дескрипторов файлов сокеты применяются в UNIX. Эта возможность оказывается удобной в тех случаях, когда требуется использование асинхронного ввода/вывода и портов завершения ввода/вывода.

\item Существуют также дополнительные, непереносимые расширения.
\end{itemize}

Работа с сокетами демонстрируется в листинге 10 и 11. Рисунок 6 показывает работу программ, из этих листингов.


Листинг 10. Сервер для работы с Win-сокетами.


\vspace{3em}



\begin{figure}[h!]
\centering
\includegraphics[scale=0.8]{img/06_Winsock}
\caption{Работа с сокетами.}
\end{figure}

\newpage
%------------------------------------------------
\chapter*{Порты завершения}
\addcontentsline{toc}{chapter}{Порты завершения}

Операциям ввода и вывода присуща более медленная скорость выполнения по сравнению с другими видами обработки. Причиной такого замедления являются следующие факторы:

\begin{itemize}
\item Задержки, обусловленные затратами времени на поиск нужных дорожек и секторов на устройствах произвольного доступа (диски, компакт-диски).

\item Задержки, обусловленные сравнительно низкой скоростью обмена данными между физическими устройствами и системной памятью.

\item Задержки при передаче данных по сети с использованием файловых, серверов, хранилищ данных и так далее.
\end{itemize}

Во всех предыдущих примерах операции ввода/вывода выполняются синхронно с потоком, поэтому весь поток вынужден простаивать, пока они не завершатся.

В этом примере показано, каким образом можно организовать продолжение выполнения потока, не дожидаясь завершения операций ввода/вывода, что будет соответствовать выполнению потоками асинхронного ввода/вывода.

Порты завершения оказываются чрезвычайно полезными при построении масштабируемых серверов, способных обеспечивать поддержку большого количества клиентов без создания для каждого из них отдельного потока. 

Листинг 12 показывает реализацию порта завершения. Для работы с ним использовался клиент из предыдущего примера. Визуальной разницы нет, но она драматически ощущается при большом количестве клиентов.


Листинг 12. Порт завершения.


\newpage
%------------------------------------------------
\chapter*{Сигналы}
\addcontentsline{toc}{chapter}{Сигналы}

В отличии от Linux, сигналы в Windows имеют сильно усеченные возможности. Наиболее сложной задаче при работе с сигналами было придумать, что можно с ними сделать. В листинге 13 по сигналу меняется цвет консоли.


Листинг 13. Сигналы в Windows.


\newpage
%------------------------------------------------
\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}

В данной работе были рассмотрены основные механизмы межпроцессорного взаимодействия, от самых простых, типа анонимных каналов, до самых сложных, таких как сокеты и порты завершения. Каждый механизм имеет свою нишу для использования.

Отдельно выделяются только сигналы, которые значительно уступают подобному механизму из мира linux.

Наиболее интересным средством взаимодействия оказался сокет. Он не имеет больших отличий от классического сокета Беркли, что упрощает его изучение. Работа в асинхронном режиме (порты завершения) оказывает драматическое влияние на скорость работы системы, и должна применяться в высоко нагруженных системах.

\end{document}
